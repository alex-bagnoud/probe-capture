#!/bin/bash
usage="$(basename "$0") [-h] [-f <zipped_genome>.gz]

Base Program for searching complete genomes for marker gene sequences using HMMER.\n
Ensure that files to be searched are gzipped .fna files from NCBI (extensions are <whatever_genomes>.fna.gz)\n\n

Inputs:\n

    -f  gzipped genome (nucleotide) fasta file. Can include multiple fasta headers\n
    -m  HMM model generated by HMMER\n"


while getopts hf:m: option
do
	case "${option}"
	in
	h) echo -e $usage; exit 1 ;;
	f) INFILE=${OPTARG};;
	m) HMM=${OPTARG};;
   \?) echo -e $usage; exit 1 ;;
	esac
done

#Translating and doing the HMM search on the AA's for a given genome fasta file as input
ASSEMBLY=$(ls "$INFILE" | sed 's/_genomic.fna.gz//g')
FNA=$(ls "$INFILE" | sed 's/\.gz$//g')

#some files have colons in the headers - need to remove these
gunzip "$INFILE"
#esl-translate gives the header ID and coordinates for the entire orf in the header of the translation. Used later to retrieve DNA
esl-translate $FNA > $ASSEMBLY'_prot.fna'
#be sure -Z esimate is correct - multiplied # genomes by 3500 orfs per genome. Also setting the domain score theshold to get hits longer than 50.
hmmsearch -Z 3619626500 -o $ASSEMBLY'.out' --cpu 0 -T 50 --noali --tblout $ASSEMBLY'.hmmout' $HMM $ASSEMBLY'_prot.fna'
 
rm $ASSEMBLY'_prot.fna'
 
#Parsing the  .hmmout file to get the coordinates of the signficant hits
 
file=$ASSEMBLY'.hmmout'

#if all lines have hashtags, just delete output, rezip file and exit
L=$(wc -l <$file)
GL=$(grep -c '#' $file)

if (($L==$GL)); then 
	echo 'No hits in '$ASSEMBLY
	gzip $FNA
	rm $file $ASSEMBLY'.out'
	exit 1
fi
 
while IFS= read -r line; do
 
 	#skipping lines with hashes
	[[ $line =~ ^\#.* ]] && continue
 
	#getting header, accession numbers and coordinates for retrieving  nucleotides
 	COORDS=$(echo $line | awk 'BEGIN {FS="[a-z]*="} {print $2 $3}')
 	ACC=$(echo $COORDS | awk -F " " '{print $1}')
 	SPEC=$(echo $line | awk 'BEGIN {FS="[a-z]*="} {print $6}')

 	#gives line number and header for the fasta entry of the hit
 	HEAD=$(grep -n $ACC $FNA | sed 's/\: /+/g')
 	LCOORDS=$((${HEAD%:*}+1))

 	#some files only have one header - need to distiguish between these and assembly files with multiple headers
 	NHEAD=$(grep -c '>' $FNA)
 	
 	if(($NHEAD > 1)); then
 	
 		#Now getting the entire fasta entry by looking for the next '>' in the file, then getting the line number
 		LEND=$(($LCOORDS+$(sed -n "$LCOORDS, $ p" $FNA | grep -n -m 1 '>' | awk -F ":" '{print $1}')-2))	
 	
 		#if LEND winds up being smaller than LCOORD, it because we've hit the end of the file. So use number lines as LEND
 		if(($LEND < $LCOORDS)); then
 	
 			LEND=$(<$FNA wc -l)
 	
 		fi
 		
 	else
 		#of takign the whole seuence to the last line, as there shoudl be no other headers
 		LEND=$(<$FNA wc -l)
 	
 	fi
 	
 	SEQ=$(sed -n "$LCOORDS, $LEND p" $FNA | tr -d '\n')

 	
 	#getting the coordinates for the hit from the header of the translated AA
 	SCOORDS=$(echo $COORDS | awk -F " " '{print $2}')
 	START=${SCOORDS%..*}
 	END=${SCOORDS#*..}
 	 	
 	if (($END < $START)); then
 
 		#echo "minus"
 		FRAGREV=$(echo $SEQ | cut -c $END-$START)
 		#reverse complementing
 		FRAG=$(echo $FRAGREV | tr "[ATCGatcg]" "[TAGCtagc]" | rev)
 		 	
 	else
 		#echo "plus"
 		FRAG=$(echo $SEQ | cut -c $START-$END)
 	fi
 
 	echo -e ">"$ASSEMBLY" source="$HEAD" start="$START" end="$END'\n'$FRAG'\n' >> $ASSEMBLY"_nucout.fna"
 
done <"$file"
 
gzip $FNA
mv $ASSEMBLY"_nucout.fna" ./NUCOUT
mv $ASSEMBLY'.out' ./HMMOUT

rm $file

